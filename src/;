use std::io::Error as Error;
use crate::array_trie::Trie;
use crate::VOCAB_SIZE;

type offset_t = Option<u32>;
type next_t= Option<u32>;
type check_t= Option<u32>;

#[derive(Debug,PartialEq)]
pub struct DoubleArray{
    next : Vec<next_t>, // 子ノードを保管
    check : Vec<check_t>, // 親ノードを保管
    offset: Vec<offset_t>, // 行ごとのスライド幅
    empty_ni : usize,      // argmin(next == -1)
    trie : Trie,    // 行列で構築ずみのトライ
}


impl DoubleArray {
    pub fn new(trie:Trie, ) -> DoubleArray{
        let next = vec![None;VOCAB_SIZE];
        let check= vec![None;VOCAB_SIZE];
        let offset = vec![None; trie.nodes.len()];
        let empty_ni = 0;
        DoubleArray{
            next,
            check,
            offset,
            empty_ni,
            trie
        }

    }
    pub fn build(&mut self){
        // 行列で表現したtrieを行(部分文字ノード)ごとに適当にスライドして１次元配列に潰す(Next配列)
        //そのスライド幅をoffsetに保存する
        // check配列は、インデックスが子ノードとして、要素には親ノードのインデックスを保存する
        
        for node_idx in 0..self.trie.nodes.len(){

            // children が存在しなければスキップ
            if self.trie.nodes[node_idx].num_child == 0 {continue;}

            let offset = self.get_offset(node_idx);

            self.update_arrays(offset);



        }


    }
    fn get_left_node_idx(&self, node_idx : usize) ->usize{
        for i in 0..VOCAB_SIZE{
            if self.trie.nodes[node_idx].children[i] != None{
                return i;
            }
        }
        panic!("Not exist children. node_idx is {}",node_idx);
    

    }
    fn get_offset(&mut self, node_idx : usize) -> offset_t{
        let mut next_empty_ni :usize= self.next[self.empty_ni].unwrap() as usize;
        let left_idx = self.get_left_node_idx(node_idx);

        
    }
    fn update_arrays(&mut self, offset : offset_t) {

    }

}
